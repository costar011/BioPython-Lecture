# -_- coding: utf-8 -_-

"""report3.ipynb

Automatically generated by Colab.

Original file is located at
https://colab.research.google.com/drive/1bJc1QsK0kXPvYxpvpxQkCJI97CHcRrDw

## 💡 문제 설명

팀의 막내인 철수는 아메리카노와 카페 라테만 판매하는 카페에서 팀원들의 커피를 사려고 합니다.

- **아메리카노**와 **카페 라테**의 가격은 차가운 것과 뜨거운 것 상관없이 각각 **4500원**, **5000원**입니다.

각 팀원에게 마실 메뉴를 적어달라고 하였고, 아래의 규칙에 따라 주문합니다.

1.  **메뉴만 적은 팀원**의 것은 **차가운 것**으로 통일합니다. (`"americano"` $\rightarrow$ 차가운 아메리카노)
2.  **"아무거나"**를 적은 팀원의 것은 **차가운 아메리카노**로 통일합니다. (`"anything"` $\rightarrow$ 차가운 아메리카노)

각 직원이 적은 메뉴가 문자열 배열 `order`로 주어질 때, 카페에서 결제하게 될 금액을 return 하는 solution 함수를 작성해주세요.

| order의 원소                       | 의미                                |
| :--------------------------------- | :---------------------------------- |
| `"iceamericano"`, `"americanoice"` | 차가운 아메리카노                   |
| `"hotamericano"`, `"americanohot"` | 따뜻한 아메리카노                   |
| `"icecafelatte"`, `"cafelatteice"` | 차가운 카페 라테                    |
| `"hotcafelatte"`, `"cafelattehot"` | 따뜻한 카페 라테                    |
| `"americano"`                      | 아메리카노 (차가운 것으로 주문)     |
| `"cafelatte"`                      | 카페 라테 (차가운 것으로 주문)      |
| `"anything"`                       | 아무거나 (차가운 아메리카노로 주문) |

---

## 🔒 제한사항

- $1 \le order$의 길이 $\le 1,000$

---

## 📝 입출력 예

| order                                                       | result  |
| :---------------------------------------------------------- | :------ |
| `["cafelatte", "americanoice", "hotcafelatte", "anything"]` | `19000` |
| `["americanoice", "americano", "iceamericano"]`             | `13500` |

### 입출력 예 설명

- **입출력 예 #1:**
  - `"cafelatte"` $\rightarrow$ 차가운 카페 라테 (5000원)
  - `"americanoice"` $\rightarrow$ 차가운 아메리카노 (4500원)
  - `"hotcafelatte"` $\rightarrow$ 따뜻한 카페 라테 (5000원)
  - `"anything"` $\rightarrow$ 차가운 아메리카노 (4500원)
  - 총합: $5000 + 4500 + 5000 + 4500 = 19000$원
- **입출력 예 #2:**
  _ 모든 음료가 차가운 아메리카노 (4500원)로 주문됩니다.
  _ 총합: $4500 \times 3 = 13500$원
  """

# 중간고사 7번 https://school.programmers.co.kr/learn/courses/30/lessons/181837

def solution1(order):
return sum([5000 if "cafelatte" in i else 4500 for i in order])

# 📝 입출력 예시 데이터

# (입력값: order, 기대값: result)

test_cases = [ # 프로그래머스 기본 입출력 예시 #1
(["cafelatte", "americanoice", "hotcafelatte", "anything"], 19000), # (5000 + 4500 + 5000 + 4500)

    # 프로그래머스 기본 입출력 예시 #2
    (["americanoice", "americano", "iceamericano"], 13500),
    # (4500 * 3)

    # 추가 테스트 케이스 1: 합이 5000원인 경우만 존재
    (["hotcafelatte", "cafelatteice"], 10000),

    # 추가 테스트 케이스 2: "anything"만 있는 경우
    (["anything", "anything", "americano"], 13500),

]

def run_tests(test_cases):
"""주어진 입출력 예시로 solution 함수를 테스트하고 결과를 출력합니다."""
print("--- ☕️ 프로그래머스 '커피 심부름' 테스트 실행 ---")

    all_passed = True

    for order, expected_result in test_cases:
        actual_result = solution1(order)

        # 결과 비교 및 출력
        if actual_result == expected_result:
            status = "✅ 통과 (PASS)"
        else:
            status = "❌ 실패 (FAIL)"
            all_passed = False

        print(f"\n[테스트] order: {order}")
        print(f"  - 기대값 (Expected): {expected_result}")
        print(f"  - 실제값 (Actual):   {actual_result}")
        print(f"  - 결과: {status}")

    print("\n----------------------------------------------")
    if all_passed:
        print("🎉 모든 테스트 케이스를 통과했습니다.")
    else:
        print("⚠️ 일부 테스트 케이스에서 오류가 발생했습니다. 코드 검토가 필요합니다.")

# 테스트 실행

if **name** == "**main**":
run_tests(test_cases)

"""## 💡 문제 설명

랜덤으로 **서로 다른 $k$개의 수**를 저장한 배열을 만들려고 합니다. 적절한 방법이 떠오르지 않기 때문에 일정한 범위 내에서 무작위로 수를 뽑은 후, 지금까지 나온 적이 없는 수이면 배열 맨 뒤에 추가하는 방식으로 만들기로 합니다.

이미 어떤 수가 무작위로 주어질지 알고 있다고 가정하고, 실제 만들어질 **길이 $k$의 배열**을 예상해봅시다.

정수 배열 `arr`가 주어집니다. 문제에서의 무작위의 수는 `arr`에 저장된 순서대로 주어질 예정이라고 했을 때, 완성될 배열을 return 하는 solution 함수를 완성해 주세요.

단, 완성될 배열의 길이가 $k$보다 작으면 나머지 값을 전부 **-1**로 채워서 return 합니다.

---

## 🔒 제한사항

- $1 \le arr$의 길이 $\le 100,000$
- $0 \le arr$의 원소 $\le 100,000$
- $1 \le k \le 1,000$

---

## 📝 입출력 예

| arr                  | k   | result           |
| :------------------- | :-- | :--------------- |
| `[0, 1, 1, 2, 2, 3]` | `3` | `[0, 1, 2]`      |
| `[0, 1, 1, 1, 1]`    | `4` | `[0, 1, -1, -1]` |

### 입출력 예 설명

- **입출력 예 #1:**
  - `arr`에서 앞에서부터 서로 다른 $k=3$개의 수를 순서대로 골라내면 `[0, 1, 2]`가 됩니다.
  - 따라서, `[0, 1, 2]`를 return 합니다.
- **입출력 예 #2:**
  _ `arr`에서 서로 다른 수는 `0`과 `1` 두 개뿐입니다.
  _ 서로 다른 수들을 앞에서부터 차례대로 저장한 `[0, 1]`에서, $k=4$를 맞추기 위해 남은 2개의 인덱스를 **-1**로 채워 넣은 `[0, 1, -1, -1]`을 return 합니다.
  """

# 중간고사 8번 https://school.programmers.co.kr/learn/courses/30/lessons/181858

def solution2(arr, k):
return result

# ----------------------------------------------------------------------

# 입출력 예시를 채점하기 위한 테스트 실행 구조

# ----------------------------------------------------------------------

# 📝 입출력 예시 데이터

# (입력값: arr, k, 기대값: result)

test_cases = [ # 프로그래머스 기본 입출력 예시 #1 (k개 채우기 성공)
([0, 1, 1, 2, 2, 3], 3, [0, 1, 2]),

    # 프로그래머스 기본 입출력 예시 #2 (k개 채우기 실패, -1 추가)
    ([0, 1, 1, 1, 1], 4, [0, 1, -1, -1]),

    # 추가 테스트 케이스 1: arr에 중복이 전혀 없는 경우
    ([1, 2, 3, 4, 5], 5, [1, 2, 3, 4, 5]),

    # 추가 테스트 케이스 2: arr의 길이가 k보다 짧은 경우 (모두 -1)
    ([10, 20], 5, [10, 20, -1, -1, -1]),

]

def run_tests(test_cases):
"""주어진 입출력 예시로 solution 함수를 테스트하고 결과를 출력합니다."""
print("--- 프로그래머스 '무작위로 K개의 수 뽑기' 테스트 실행 ---")

    all_passed = True

    for arr, k, expected_result in test_cases:
        actual_result = solution2(arr, k)

        # 결과 비교 및 출력
        if actual_result == expected_result:
            status = "✅ 통과 (PASS)"
        else:
            status = "❌ 실패 (FAIL)"
            all_passed = False

        print(f"\n[테스트] arr: {arr}, k: {k}")
        print(f"  - 기대값 (Expected): {expected_result}")
        print(f"  - 실제값 (Actual):   {actual_result}")
        print(f"  - 결과: {status}")

    print("\n---------------------------------------------------------")
    if all_passed:
        print("🎉 모든 테스트 케이스를 통과했습니다.")
    else:
        print("⚠️ 일부 테스트 케이스에서 오류가 발생했습니다. 코드 검토가 필요합니다.")

# 테스트 실행

run_tests(test_cases)

"""## 💡 문제 설명

정수 배열 `arr`와 `query`가 주어집니다.

`query`를 순회하면서 다음 작업을 반복합니다.

1.  **짝수 인덱스**($0, 2, 4, \dots$)에서는 `arr`에서 `query[i]`번 인덱스를 기준으로 **배열의 뒷부분을 잘라서 버립니다.** (즉, `query[i]`번 인덱스까지 남김)
2.  **홀수 인덱스**($1, 3, 5, \dots$)에서는 `arr`에서 `query[i]`번 인덱스를 기준으로 **배열의 앞부분을 잘라서 버립니다.** (즉, `query[i]`번 인덱스부터 남김)

위 작업을 마친 후 남은 `arr`의 부분 배열을 return 하는 solution 함수를 완성해 주세요.

---

## 🔒 제한사항

- $5 \le arr$의 길이 $\le 100,000$
- $0 \le arr$의 원소 $\le 100$
- $1 \le query$의 길이 $< \min(50, arr$의 길이 $/ 2)$
- `query`의 각 원소는 0보다 크거나 같고 남아있는 `arr`의 길이보다 작습니다.

---

## 📝 입출력 예

| arr                  | query       | result      |
| :------------------- | :---------- | :---------- |
| `[0, 1, 2, 3, 4, 5]` | `[4, 1, 2]` | `[1, 2, 3]` |

### 입출력 예 설명

| `query` 인덱스 | `query` 값 | 처리 전 `arr`        | `arr` 변경 규칙                 | 처리 후 `arr`     |
| :------------- | :--------- | :------------------- | :------------------------------ | :---------------- |
| $i=0$ (짝수)   | $4$        | `[0, 1, 2, 3, 4, 5]` | 인덱스 4까지 남기고 뒷부분 버림 | `[0, 1, 2, 3, 4]` |
| $i=1$ (홀수)   | $1$        | `[0, 1, 2, 3, 4]`    | 인덱스 1부터 남기고 앞부분 버림 | `[1, 2, 3, 4]`    |
| $i=2$ (짝수)   | $2$        | `[1, 2, 3, 4]`       | 인덱스 2까지 남기고 뒷부분 버림 | `[1, 2, 3]`       |

따라서, 최종 결과는 `[1, 2, 3]`을 return 합니다.
"""

# 중간고사 9번 https://school.programmers.co.kr/learn/courses/30/lessons/181893

def solution3(arr, query):
for i in range(len(query)):
if i % 2 == 0:
arr = arr[:query[i]+1]
else:
arr = arr[query[i]:]
return arr

# ----------------------------------------------------------------------

# 입출력 예시를 채점하기 위한 테스트 실행 구조

# ----------------------------------------------------------------------

# 📝 입출력 예시 데이터

# (입력값: arr, query, 기대값: result)

test_cases = [ # 프로그래머스 기본 입출력 예시
([0, 1, 2, 3, 4, 5], [4, 1, 2], [1, 2, 3]),

    # 추가 테스트 케이스 1: 쿼리가 하나만 있는 경우 (짝수 인덱스)
    ([10, 20, 30, 40, 50], [2], [10, 20, 30]),

    # 추가 테스트 케이스 2: 쿼리가 하나만 있는 경우 (홀수 인덱스 시뮬레이션: 쿼리 인덱스가 1인 경우)
    ([10, 20, 30, 40, 50], [0, 2], [30, 40, 50]), # i=0: [10, 20, 30]; i=1: [30, 40, 50]

    # 추가 테스트 케이스 3: 배열이 한 원소만 남는 경우
    ([0, 1, 2, 3], [0, 0, 0], [0]) # i=0: [0]; i=1: [0]; i=2: [0]

]

def run_tests(test_cases):
"""주어진 입출력 예시로 solution3 함수를 테스트하고 결과를 출력합니다."""
print("--- 프로그래머스 '배열 조각하기' 테스트 실행 ---")

    all_passed = True

    for arr, query, expected_result in test_cases:
        actual_result = solution3(arr, query)

        # 결과 비교 및 출력
        if actual_result == expected_result:
            status = "✅ 통과 (PASS)"
        else:
            status = "❌ 실패 (FAIL)"
            all_passed = False

        print(f"\n[테스트] arr: {arr}, query: {query}")
        print(f"  - 기대값 (Expected): {expected_result}")
        print(f"  - 실제값 (Actual):   {actual_result}")
        print(f"  - 결과: {status}")

    print("\n-------------------------------------------------")
    if all_passed:
        print("🎉 모든 테스트 케이스를 통과했습니다.")
    else:
        print("⚠️ 일부 테스트 케이스에서 오류가 발생했습니다. 코드 검토가 필요합니다.")

# 테스트 실행

run_tests(test_cases)

"""## 💡 문제 설명

문자열 `code`가 주어집니다.

`code`를 앞에서부터 읽으면서 만약 문자가 **"1"**이면 **`mode`를 바꿉니다.** `mode`에 따라 `code`를 읽어가면서 문자열 `ret`을 만들어냅니다.

`mode`는 $0$과 $1$이 있으며, 인덱스 `idx`를 $0$부터 `code`의 길이 $- 1$까지 1씩 키워나가면서 `code[idx]`의 값에 따라 다음과 같이 행동합니다. (단, 시작할 때 **`mode`는 0**입니다.)

### 1. `mode`가 0일 때

- `code[idx]`가 **"1"이 아니면**: `idx`가 **짝수**일 때만 `ret`의 맨 뒤에 `code[idx]`를 추가합니다.
- `code[idx]`가 **"1"이면**: `mode`를 0에서 1로 바꿉니다.

### 2. `mode`가 1일 때

- `code[idx]`가 **"1"이 아니면**: `idx`가 **홀수**일 때만 `ret`의 맨 뒤에 `code[idx]`를 추가합니다.
- `code[idx]`가 **"1"이면**: `mode`를 1에서 0으로 바꿉니다.

문자열 `code`를 통해 만들어진 문자열 `ret`를 return 하는 solution 함수를 완성해 주세요.

단, return 하려는 `ret`가 만약 **빈 문자열이라면 대신 "EMPTY"를 return 합니다.**

---

## 🔒 제한사항

- $1 \le code$의 길이 $\le 100,000$
- `code`는 알파벳 소문자 또는 "1"로 이루어진 문자열입니다.

---

## 📝 입출력 예

| code            | result    |
| :-------------- | :-------- |
| `"abc1abc1abc"` | `"acbac"` |

### 입출력 예 설명

| $i$ (idx) | `code[i]` | `mode` (처리 전) | `code[i]` 처리 결과   | `mode` (처리 후) | `ret`    |
| :-------- | :-------- | :--------------- | :-------------------- | :--------------- | :------- |
| $0$       | `"a"`     | $0$              | 짝수 인덱스, 추가     | $0$              | `"a"`    |
| $1$       | `"b"`     | $0$              | 홀수 인덱스, 무시     | $0$              | `"a"`    |
| $2$       | `"c"`     | $0$              | 짝수 인덱스, 추가     | $0$              | `"ac"`   |
| $3$       | `"1"`     | $0$              | `"1"`이므로 mode 변경 | $1$              | `"ac"`   |
| $4$       | `"a"`     | $1$              | 짝수 인덱스, 무시     | $1$              | `"ac"`   |
| $5$       | `"b"`     | $1$              | 홀수 인덱스, 추가     | $1$              | `"acb"`  |
| $6$       | `"c"`     | $1$              | 짝수 인덱스, 무시     | $1$              | `"acb"`  |
| $7$       | `"1"`     | $1$              | `"1"`이므로 mode 변경 | $0$              | `"acb"`  |
| $8$       | `"a"`     | $0$              | 짝수 인덱스, 추가     | $0$              | `"acba"` |
| $9$       | `"b"`     | $0$              | 홀수 인덱스, 무시     | $0$              | `"acba"` |
| $10$      | `"c"`     | $0$              | 짝수 인덱스, 추가     | $0$              | `"acbac  |

"""

# 중간고사 10번 https://school.programmers.co.kr/learn/courses/30/lessons/181932

def solution4(code):
return result

# 📝 입출력 예시 데이터

test_cases = [

# (입력값: code, 기대값: result)

("abc1abc1abc", "acbac"), # 입출력 예 #1
("10101", "00"), # 추가 테스트 케이스 1
("1", "EMPTY"), # 추가 테스트 케이스 2
("a1b1c", "a"), # 추가 테스트 케이스 3
("0110", "0") # 추가 테스트 케이스 4
]

def run_tests(test_cases):
"""주어진 입출력 예시로 solution4 함수를 테스트하고 결과를 출력합니다."""
print("--- 프로그래머스 입출력 예시 채점 시뮬레이션 ---")

    all_passed = True

    for input_code, expected_result in test_cases:
        actual_result = solution4(input_code)

        # 결과 비교 및 출력
        if actual_result == expected_result:
            status = "✅ 통과 (PASS)"
        else:
            status = "❌ 실패 (FAIL)"
            all_passed = False

        print(f"\n[테스트] code: \"{input_code}\"")
        print(f"  - 기대값 (Expected): \"{expected_result}\"")
        print(f"  - 실제값 (Actual):   \"{actual_result}\"")
        print(f"  - 결과: {status}")

    print("\n----------------------------------------------")
    if all_passed:
        print("🎉 모든 테스트 케이스를 통과했습니다.")
    else:
        print("⚠️ 일부 테스트 케이스에서 오류가 발생했습니다.")

# 테스트 실행

run_tests(test_cases)

"""## 📐 문제 설명

2차원 정수 배열 `board`와 정수 $k$가 주어집니다.

$i + j \le k$를 만족하는 모든 $(i, j)$에 대한 `board[i][j]`의 합을 return 하는 solution 함수를 완성해 주세요.

---

## 🔒 제한사항

- $1 \le$ `board`의 길이 $\le 100$
- $1 \le$ `board[i]`의 길이 $\le 100$
- $1 \le$ `board[i][j]` $\le 10,000$
- 모든 `board[i]`의 길이는 같습니다.
- $0 \le k <$ `board`의 길이 $+`board[i]$의 길이`

---

## 📝 입출력 예

| board                                          | k   | result |
| :--------------------------------------------- | :-- | :----- |
| `[[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]]` | 2   | 8      |

### 입출력 예 설명

입력된 `board`를 표로 나타내고 인덱스 합 $i+j$를 계산하면 다음과 같습니다.

| $i \setminus j$ | **0** | **1** | **2** |
| :-------------: | :---: | :---: | :---: |
|      **0**      | **0** | **1** | **2** |
|      **1**      | **1** | **2** | **3** |
|      **2**      | **2** | **3** | **4** |
|      **3**      | **3** | **4** | **5** |

$i + j \le 2$를 만족하는 원소들의 합은 다음과 같습니다.
$$0 + 1 + 2 + 1 + 2 + 2 = 8$$

따라서 $8$을 return 합니다.
"""

# https://school.programmers.co.kr/learn/courses/30/lessons/181829

def solution5(board, k):
return result

# ----------------------------------------------------------------------

# 📝 입출력 예시 데이터

# (입력값: board, k, 기대값: result)

test_cases = [ # 프로그래머스 기본 입출력 예시
([[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5]], 2, 8),

    # 추가 테스트 케이스 1: k=0 (첫 번째 원소만 포함)
    ([[10, 20], [30, 40]], 0, 10),

    # 추가 테스트 케이스 2: k가 충분히 커서 모든 원소를 포함 (k=5)
    ([[1, 1], [1, 1]], 5, 4),

]

def run_tests(test_cases):
"""주어진 입출력 예시로 solution5 함수를 테스트하고 결과를 출력합니다."""
print("--- 📐 프로그래머스 '이차원 배열 대각선 순회하기' 테스트 실행 ---")

    all_passed = True

    for board, k, expected_result in test_cases:
        actual_result = solution5(board, k)

        # 결과 비교 및 출력
        if actual_result == expected_result:
            status = "✅ 통과 (PASS)"
        else:
            status = "❌ 실패 (FAIL)"
            all_passed = False

        print(f"\n[테스트] k={k}, board 크기: {len(board)}x{len(board[0])}")
        print(f"  - 기대값 (Expected): {expected_result}")
        print(f"  - 실제값 (Actual):   {actual_result}")
        print(f"  - 결과: {status}")

    print("\n-----------------------------------------------------------")
    if all_passed:
        print("🎉 모든 테스트 케이스를 통과했습니다.")
    else:
        print("⚠️ 일부 테스트 케이스에서 오류가 발생했습니다. 코드 검토가 필요합니다.")

# 테스트 실행

if **name** == "**main**":
run_tests(test_cases)
