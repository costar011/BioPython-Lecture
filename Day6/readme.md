## 💡 문제 설명

정수로 이루어진 문자열 `n_str`이 주어질 때, `n_str`의 가장 왼쪽에 처음으로 등장하는 **0들을 뗀 문자열**을 return하도록 solution 함수를 완성해주세요.

---

## 🔒 제한사항

- $2 \le n\_str$의 길이 $\le 10$
- `n_str`이 "0"으로만 이루어진 경우는 없습니다.

---

## 📝 입출력 예

| n_str      | result     |
| :--------- | :--------- |
| `"0010"`   | `"10"`     |
| `"854020"` | `"854020"` |

### 입출력 예 설명

- **입출력 예 #1:** `"0010"`의 가장 왼쪽에 연속으로 등장하는 `"0"`을 모두 제거하면 `"10"`이 됩니다.
- **입출력 예 #2:** `"854020"`는 가장 왼쪽에 0이 없으므로 `"854020"`을 return합니다.

## 💡 문제 설명

정수 리스트 `num_list`가 주어집니다. 가장 첫 번째 원소를 1번 원소라고 할 때, **홀수 번째 원소들의 합**과 **짝수 번째 원소들의 합** 중 큰 값을 return 하도록 solution 함수를 완성해주세요. 두 값이 같을 경우 그 값을 return합니다.

---

## 🔒 제한사항

- $5 \le num\_list$의 길이 $\le 50$
- $-9 \le num\_list$의 원소 $\le 9$

---

## 📝 입출력 예

| num_list             | result |
| :------------------- | :----- |
| `[4, 2, 6, 1, 7, 6]` | `17`   |
| `[-1, 2, 5, 6, 3]`   | `8`    |

### 입출력 예 설명

- **입출력 예 #1:**
  - 홀수 번째 원소들의 합: $4 + 6 + 7 = 17$
  - 짝수 번째 원소들의 합: $2 + 1 + 6 = 9$
  - 따라서, $17$을 return합니다.
- **입출력 예 #2:**
  - 홀수 번째 원소들의 합: $-1 + 5 + 3 = 7$
  - 짝수 번째 원소들의 합: $2 + 6 = 8$
  - 따라서, $8$을 return합니다.

## 💡 문제 설명

'm'과 "rn"이 모양이 비슷하게 생긴 점을 활용해 문자열에 장난을 하려고 합니다.
문자열 `rny_string`이 주어질 때, `rny_string`의 모든 **'m'을 "rn"으로 바꾼 문자열**을 return 하는 solution 함수를 작성해 주세요.

---

## 🔒 제한사항

- $1 \le rny\_string$의 길이 $\le 100$
- `rny_string`은 영소문자로만 이루어져 있습니다.

---

## 📝 입출력 예

| rny_string      | result            |
| :-------------- | :---------------- |
| `"masterpiece"` | `"rnasterpiece"`  |
| `"programmers"` | `"prograrnrners"` |
| `"jerry"`       | `"jerry"`         |
| `"burn"`        | `"burn"`          |

### 입출력 예 설명

- **입출력 예 #1:**
  - `rny_string`의 'm'을 "rn"으로 바꾸면 `"rnasterpiece"`를 return 합니다.
- **입출력 예 #2:**
  - `rny_string`의 두 개의 'm'을 각각 "rn"으로 바꾸면 `"prograrnrners"`를 return 합니다.
- **입출력 예 #3, #4:**
  - 'm'이 없는 경우, `rny_string` 그대로를 return 합니다.

## 💡 문제 설명

알파벳으로 이루어진 문자열 `myString`과 `pat`이 주어집니다. `myString`의 연속된 부분 문자열 중 `pat`이 존재하면 **1**을, 그렇지 않으면 **0**을 return 하는 solution 함수를 완성해 주세요.

단, 알파벳 **대문자와 소문자는 구분하지 않습니다.**

---

## 🔒 제한사항

- $1 \le myString$의 길이 $\le 100,000$
- $1 \le pat$의 길이 $\le 300$
- `myString`과 `pat`은 모두 알파벳으로 이루어진 문자열입니다.

---

## 📝 입출력 예

| myString    | pat       | return |
| :---------- | :-------- | :----- |
| `"AbCdEfG"` | `"aBc"`   | `1`    |
| `"aaAA"`    | `"aaaaa"` | `0`    |

### 입출력 예 설명

- **입출력 예 #1:**
  - 대소문자를 구분하지 않으므로, `myString`의 `"AbC"`는 `pat`인 `"aBc"`와 동일하게 간주됩니다.
  - 따라서, **1**을 return 합니다.
- **입출력 예 #2:**
  - `myString`의 길이가 `pat`의 길이보다 짧으므로, `myString`의 부분 문자열 중 `pat`과 같은 문자열이 존재할 수 없습니다.
  - 따라서, **0**을 return 합니다.

## 💡 문제 설명

최대 5명씩 탑승가능한 놀이기구를 타기 위해 줄을 서있는 사람들의 이름이 담긴 문자열 리스트 `names`가 주어질 때, **앞에서 부터 5명씩 묶은 그룹의 가장 앞에 서있는 사람들의 이름**을 담은 리스트를 return하도록 solution 함수를 완성해주세요.

마지막 그룹이 5명이 되지 않더라도 가장 앞에 있는 사람의 이름을 포함합니다.

---

## 🔒 제한사항

- $5 \le names$의 길이 $\le 30$
- $1 \le names$의 원소의 길이 $\le 10$
- `names`의 원소는 영어 알파벳 소문자로만 이루어져 있습니다.

---

## 📝 입출력 예

| names                                                        | result            |
| :----------------------------------------------------------- | :---------------- |
| `["nami", "ahri", "jayce", "garen", "ivern", "vex", "jinx"]` | `["nami", "vex"]` |

### 입출력 예 설명

- **입출력 예 #1:**
  - 앞에서부터 5명씩 두 그룹으로 묶을 수 있습니다.
    - 그룹 1: `["nami", "ahri", "jayce", "garen", "ivern"]`
    - 그룹 2: `["vex", "jinx"]`
  - 이 두 그룹에서 가장 앞에 서있는 사람들의 이름은 `"nami"`와 `"vex"`이므로, 리스트인 `["nami", "vex"]`를 return합니다.
